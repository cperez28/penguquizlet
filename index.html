<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pengu Quizlet</title>
  <style>
    /* Pastel palette tuned for a friendly learning experience */
    :root {
      --bg: #fff7fb;
      --panel: #ffe9f4;
      --muted: #8a8a9e;
      --ink: #3b3b45;
      --accent: #ff76b9;
      --accent2: #ffa6cf;
      --accent3: #ffd1e8;
      --chip: #fff0f8;
      --border: #f7c6dc;
      --success: #22c55e;
      --warn: #f59e0b;
      --danger: #ef4444;
      --shadow: 0 10px 28px rgba(255, 118, 185, 0.28);
    }
    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial;
      color: var(--ink);
      background: linear-gradient(180deg, var(--bg), var(--panel));
      /* Base font size tuned for consistent readability across modes */
      font-size: 18px;
    }
    .container {
      max-width: 1100px;
      margin: auto;
      padding: 24px;
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 800;
      letter-spacing: 0.3px;
    }
    /* Brand icon: simple circle with P letter instead of external image */
    .pengu {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--accent);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: #fff;
      box-shadow: var(--shadow);
      font-family: 'Segoe UI', sans-serif;
    }
    .tabs {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    button, select, input, textarea {
      background: var(--chip);
      color: var(--ink);
      border: 1px solid var(--border);
      padding: 8px 12px;
      border-radius: 12px;
    }
    button {
      cursor: pointer;
      transition: transform 0.06s ease;
    }
    button:hover {
      transform: translateY(-1px);
    }
    button.primary {
      background: var(--accent);
      border-color: #ff5cab;
      color: white;
      box-shadow: var(--shadow);
    }
    button.ghost {
      background: transparent;
      border-color: var(--border);
    }
    button.warn {
      background: var(--warn);
      color: #111827;
      border-color: #b45309;
    }
    button.danger {
      background: var(--danger);
      border-color: #b91c1c;
      color: white;
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 16px;
      margin-top: 12px;
      box-shadow: var(--shadow);
    }
    .grid {
      display: grid;
      gap: 12px;
    }
    .grid.cols-2 {
      grid-template-columns: 1fr 1fr;
    }
    .list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .item {
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 12px;
      box-shadow: var(--shadow);
    }
    .row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .space-between {
      justify-content: space-between;
    }
    .hidden {
      display: none !important;
    }
    .pill {
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: 0.75rem;
      color: var(--muted);
      background: #fff;
    }
    .progress {
      height: 10px;
      background: #ffe9f4;
      border-radius: 999px;
      border: 1px solid var(--border);
      overflow: hidden;
    }
    .progress > div {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent2));
    }

    /* Image support for cards and learn/test modes */
    .card-image {
      max-width: 100%;
      max-height: 180px;
      margin-top: 8px;
      border-radius: 12px;
    }
    .learn-image, .test-image {
      max-width: 100%;
      max-height: 200px;
      margin-top: 8px;
      border-radius: 12px;
    }
    /* Flashcards */
    .flash-wrap {
      position: relative;
      min-height: 300px;
    }
    .flash-card {
      position: relative;
      margin: auto;
      max-width: 820px;
      height: 360px;
      perspective: 1200px;
      cursor: pointer;
    }
    .flash-card2 {
      position: relative;
      margin: auto;
      max-width: 760px;
      height: 300px;
      perspective: 1200px;
      cursor: pointer;
    }
    .flash-inner {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 0.5s;
      transform-style: preserve-3d;
      border-radius: 22px;
      border: 1px solid var(--border);
      background: #fff;
      box-shadow: var(--shadow);
    }
    .flash-inner.flipped {
      transform: rotateY(180deg);
    }
    .flash-face {
      position: absolute;
      inset: 0;
      backface-visibility: hidden;
      display: grid;
      place-items: center;
      padding: 18px;
      border-radius: 22px;
    }
    .flash-front {
      background: linear-gradient(135deg, #fff, var(--panel));
    }
    .flash-back {
      transform: rotateY(180deg);
      background: linear-gradient(135deg, #fff, var(--accent3));
    }
    .term {
      /* Moderate large font for terms in flashcards */
      font-size: 2rem;
      text-align: center;
    }
    .def {
      /* Slightly smaller font for definitions */
      font-size: 1.3rem;
      color: #5b5563;
      text-align: center;
    }
    .full-screen {
      position: fixed;
      inset: 0;
      padding: 24px;
      background: rgba(255, 240, 248, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
    }
    .correct {
      border-color: var(--success);
      background: linear-gradient(0deg, #f0fff4, #ffffff);
    }
    .incorrect {
      border-color: var(--danger);
      background: linear-gradient(0deg, #fff5f5, #ffffff);
    }
    .chart {
      display: flex;
      gap: 10px;
      align-items: flex-end;
      height: 140px;
      padding: 8px;
      border: 1px dashed var(--border);
      border-radius: 12px;
      background: #fff;
    }
    /* Close button for flash full screen */
    .close-full {
      position: absolute;
      top: 12px;
      right: 12px;
      background: var(--accent);
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      font-size: 1.2rem;
      line-height: 32px;
      text-align: center;
      cursor: pointer;
      box-shadow: var(--shadow);
    }

    /* Custom image for penguin icon */
    .pengu-img {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      object-fit: cover;
      box-shadow: var(--shadow);
    }

    /* Learn cards sized like flashcards */
    .learn-card {
      max-width: 820px;
      margin: auto;
    }
    .bar {
      width: 64px;
      background: linear-gradient(180deg, var(--accent), var(--accent2));
      border-radius: 10px 10px 0 0;
      position: relative;
    }
    .bar .label {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8rem;
      color: #555;
      white-space: nowrap;
    }
    /* Memory match cards */
    .match-grid {
      display: grid;
      gap: 8px;
    }
    .match-card {
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 16px;
      /* Allow cards to grow when content wraps */
      /* Provide extra height so long terms/definitions fit within the card */
      min-height: 150px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      box-shadow: var(--shadow);
      transition: background 0.2s;
      padding: 8px;
      text-align: center;
      /* Standardize memory card font and allow wrapping of long text */
      font-size: 1rem;
      white-space: normal;
      overflow-wrap: anywhere;
      word-break: break-word;
      line-height: 1.2;
    }
    .match-card.revealed {
      background: var(--accent3);
    }
    .match-card.matched {
      background: var(--accent2);
    }
    /* --- Additional styles to harmonize font sizes across modes --- */
    /* Test (Probar) area: moderate question and definition sizes */
    #test-area .term {
      font-size: 1.6rem;
      text-align: left;
      margin-bottom: 6px;
    }
    #test-area .def {
      font-size: 1.1rem;
    }
    #test-area label {
      font-size: 1rem;
    }
    #test-area .muted {
      font-size: 1rem;
    }
    #test-area input[type="text"] {
      font-size: 1rem;
      padding: 6px 8px;
    }
    #test-area select,
    #test-area option {
      font-size: 1rem;
    }
    /* Combination (Combinar) area: adjust term and select sizes */
    .comb-term {
      font-size: 1.3rem;
      line-height: 1.25;
      max-width: 100%;
    }
    #comb-area select {
      font-size: 1rem;
      width: 100%;
      max-width: 100%;
    }
    #comb-area .row .muted {
      font-size: 1rem;
    }
    /* Allow combination rows to wrap on small screens */
    #comb-area .row {
      flex-wrap: wrap;
    }
    #comb-area .row .comb-term,
    #comb-area .row select {
      flex: 1 1 100%;
      margin-top: 4px;
    }
    @media (min-width: 600px) {
      #comb-area .row .comb-term,
      #comb-area .row select {
        flex: 1 1 48%;
      }
    }
    /* Pair (Parear) area: adjust button text size */
    #pair-area .item {
      font-size: 1.2rem;
      padding: 6px 8px;
    }
    /* Learn cards: moderate fonts within learn mode */
    .learn-card .term {
      font-size: 1.6rem;
      line-height: 1.3;
    }
    .learn-card .def {
      font-size: 1.2rem;
    }
    .learn-card .item {
      font-size: 1.2rem;
    }
    .scrim {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.25);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 90;
    }
    .modal {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      max-width: 720px;
      width: 92%;
      padding: 16px;
      box-shadow: var(--shadow);
    }
    #confetti {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 100;
    }

    /* === Styles for Cloze + Elaboraci√≥n game === */
    .cloze-def {
      background: var(--chip);
      border: 1px dashed var(--border);
      padding: 12px;
      border-radius: 12px;
    }
    .blank {
      display: inline-block;
      min-width: 90px;
      border-bottom: 2px solid var(--accent);
      text-align: center;
      padding: 0 4px;
      margin: 0 2px;
    }
    .chips {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin: 6px 0;
    }
    .chip {
      border: 1px dashed var(--border);
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
    }
    .fb-box {
      margin-top: 8px;
      padding: 8px 12px;
      border-radius: 10px;
      background: var(--panel);
      border: 1px solid var(--border);
    }
    .bar {
      height: 8px;
      background: var(--chip);
      border: 1px solid var(--border);
      border-radius: 999px;
      overflow: hidden;
    }
    .bar > span {
      display: block;
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--accent), var(--accent2));
    }
    .badge {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: 12px;
    }
    .badge.ok {
      color: var(--success);
      border-color: var(--success);
    }
    .badge.warn {
      color: var(--warn);
      border-color: var(--warn);
    }
    .badge.err {
      color: var(--danger);
      border-color: var(--danger);
    }
    /* Le√©lo T√∫ buttons styling */
    .leelo-btn {
      font-size: 1.7rem;
      padding: 10px 14px;
      background: var(--chip);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: var(--shadow);
      cursor: pointer;
    }
    .leelo-btn:hover:not([disabled]) {
      transform: translateY(-1px);
    }
    .leelo-btn[disabled] {
      opacity: 0.5;
      cursor: default;
    }
    /* Flash TTS button styling */
    #flash-tts {
      font-size: 1.4rem;
      padding: 8px 12px;
    }
    #flash-tts[disabled] {
      opacity: 0.5;
      cursor: default;
    }
    /* Prev/Next buttons for Le√©lo */
    #leelo-prev, #leelo-next {
      font-size: 1.6rem;
    }

    flashcard-transparent {
    background: rgba(255, 255, 255, 0.2); /* transparencia */
    backdrop-filter: blur(8px); /* efecto cristal */
    border-radius: 14px;
    padding: 20px;
    width: 86%;
    max-width: 780px;
    margin: 14px auto;
    text-align: center;
    border: 1px solid rgba(255, 255, 255, 0.25);
    box-shadow: 0 8px 28px rgba(0, 0, 0, 0.15);
  }
  .flashcard-transparent .term {
    font-size: clamp(24px, 4.5vw, 40px);
    font-weight: 900;
    color: var(--accent, #d94f87);
    margin-bottom: 10px;
  }
  .flashcard-transparent .def {
    font-size: clamp(16px, 2.5vw, 22px);
    color: #fff;
    line-height: 1.75;
  }
</style>
  </style>
</head>
<body>
  <!-- Confetti canvas for celebrations -->
  <canvas id="confetti"></canvas>
  <div class="container">
    <header>
      <div class="row" style="gap: 12px">
        <div class="brand"><img src="penguin.png" alt="Pengu" class="pengu-img"><span>Pengu Quizlet</span></div>
        <span class="pill">Sin internet ¬∑ LocalStorage</span>
      </div>
      <div class="tabs">
        <button id="nav-sets" class="primary">Sets</button>
        <button id="nav-flash">Flashcards</button>
        <button id="nav-leelo">L√©elo T√∫</button>
        <button id="nav-learn">Learn</button>
        <button id="nav-test">Probar</button>
        <button id="nav-memory">Memorama</button>
        <button id="nav-comb">Combinar</button>
        <button id="nav-pair">Parear</button>
        <button id="nav-cloze">Elaborar</button>
        <button id="nav-import">Importar/Exportar</button>
      </div>
    </header>

    <!-- Sets view -->
    <section id="view-sets" class="panel">
      <div class="row space-between">
        <h3 class="section-title">Mis sets</h3>
        <div class="row" style="gap: 8px">
          <button id="btn-new-set">Nuevo set</button>
          <button id="btn-new-folder" class="ghost">Nueva carpeta</button>
          <button id="btn-clear" class="danger">Borrar todo</button>
        </div>
      </div>
      <div id="sets-list" class="list"></div>
    </section>

    <!-- Flashcards view -->
    <section id="view-flash" class="panel hidden">
      <div class="row space-between">
        <h3 class="section-title">Flashcards</h3>
        <div class="row" style="gap: 6px; flex-wrap: wrap">
          <select id="select-flash"></select>
          <button id="flash-reverse" class="ghost" title="Intercambiar Term/Def">Term‚ÜîDef</button>
          <button id="flash-shuffle" class="ghost" title="Aleatorizar">Aleatorio</button>
        <button id="flash-auto" class="ghost" title="Activar auto-reproducci√≥n">Auto</button>
        </div>
      </div>
      <div class="flash-wrap" id="flash-wrap">
        <div class="flash-card" id="flash-card">
          <div class="flash-inner" id="flash-inner">
            <div class="flash-face flash-front"><div class="term" id="flash-front">‚Äî</div></div>
            <div class="flash-face flash-back"><div class="def" id="flash-back">(haz clic o presiona espacio)</div></div>
          </div>
        </div>
      </div>
      <div class="row" id="flash-grade-row" style="gap: 10px; justify-content: center; margin-top: 20px">
        <button id="flash-prev" class="ghost" title="Anterior Flashcard">Anterior</button>
        <button id="flash-show" class="primary">Voltear</button>
        <button id="flash-tts" class="ghost" title="Escuchar Modelo">üîà</button>
        <button id="flash-next" class="ghost" title="Siguiente Flashcard">Siguiente</button>
      </div>
      <p class="muted" style="text-align:center">Atajos: ‚Üê ‚Üí ¬∑ Espacio ¬∑ Swipe para cambiar</p>
    </section>

    <!-- Leelo T√∫ view -->
    <section id="view-leelo" class="panel hidden">
      <div class="row space-between">
        <h3 class="section-title">L√©elo T√∫</h3>
        <div class="row" style="gap:6px; flex-wrap:wrap">
          <select id="select-leelo"></select>
          <label class="pill"><input type="checkbox" id="leelo-auto"> Auto‚Äëgrabar al abrir</label>
          <label class="pill"><input type="checkbox" id="leelo-auto-advance"> Avanzar al guardar</label>
        </div>
      </div>
      <div id="leelo-card" class="panel" style="margin-top:12px; text-align:center; padding:20px;">
        <!-- La tarjeta-->
        
        <div class="flash-card2" id="flash-wrap">
          <div class="flash-inner" id="flash-card">
              <div class="term" id="leelo-term">‚Äî</div>
              <div class="def" id="leelo-def">Seleccione un set.</div>
          </div>
        </div>

        <div class="row" id="leelo-controls" style="justify-content:center; gap:10px; margin-top:20px;">
          <button id="leelo-prev" class="ghost" title="Anterior Flashcard">Anterior</button>
          <button id="leelo-rec" class="leelo-btn" title="Grabar">üéôÔ∏è</button>
          <button id="leelo-stop" class="leelo-btn" title="Detener" disabled>‚èπÔ∏è</button>
          <button id="leelo-play" class="leelo-btn" title="Escuchar mi lectura" disabled>‚ñ∂Ô∏è</button>
          <button id="leelo-retry" class="leelo-btn" title="Repetir" disabled>üîÑ</button>
          <button id="leelo-tts" class="leelo-btn" title="Lectura modelo">üì¢</button>
          <button id="leelo-next" class="ghost" title="Siguiente Flashcard">Siguiente</button>
        </div>
        <!-- Timer and score row -->
        <div class="row" style="justify-content:center; gap:12px; margin-top:12px;">
          <span class="pill" id="leelo-timer" style="font-weight:600">00:00</span>
          <span class="pill" id="leelo-score" style="font-weight:600">0 pts</span>
        </div>
        <div id="leelo-recent" class="sec" style="text-align:center; margin-top:14px;">
          <audio id="leelo-audio" controls style="width:260px;"></audio>
          <div class="muted" id="leelo-when"></div>
        </div>
           
      </div>
    </section>

    <!-- Learn view -->
    <section id="view-learn" class="panel hidden">
      <div class="row space-between">
        <h3 class="section-title">Learn</h3>
        <div class="row" style="gap: 6px; flex-wrap: wrap">
          <select id="select-learn"></select>
          <select id="learn-mode">
            <option value="mix">Mixto</option>
            <option value="mcq">Opci√≥n m√∫ltiple</option>
            <option value="type">Escribir</option>
            <option value="judge">Verdadero/Falso</option>
          </select>
          <select id="learn-direction" title="Direcci√≥n de pr√°ctica">
            <option value="auto">Auto (mezclado)</option>
            <option value="term">Escribir t√©rmino (desde definici√≥n)</option>
            <option value="def">Escribir definici√≥n (desde t√©rmino)</option>
          </select>
          <button id="learn-reset" class="ghost">Reiniciar progreso</button>
        </div>
      </div>
      <div id="learn-stage" class="grid" style="grid-template-columns: 1fr; gap: 12px"></div>
      <div class="progress" style="margin-top:8px"><div id="learn-progress" style="width:0%"></div></div>
      <div class="row" style="gap: 8px; margin-top: 8px"><span class="pill" id="learn-stats">‚Äî</span></div>
    </section>

    <!-- Test view -->
    <section id="view-test" class="panel hidden">
      <div class="row space-between">
        <h3 class="section-title">Probar</h3>
        <div class="row" style="gap: 6px; flex-wrap: wrap">
          <select id="select-test"></select>
          <label class="pill">Preguntas <input id="test-count" type="number" value="10" min="5" max="50" style="width:70px; margin-left:6px"></label>
          <select id="test-mode">
            <option value="balanced">Balanceado</option>
            <option value="mcq">Solo opci√≥n m√∫ltiple</option>
            <option value="tf">Solo V/F</option>
            <option value="short">Solo respuesta corta</option>
          </select>
          <button id="test-generate" class="primary">Generar</button>
        </div>
      </div>
      <div id="test-area" class="grid" style="grid-template-columns: 1fr; gap: 12px"></div>
      <div id="test-actions" class="row" style="gap:10px; margin-top:8px; align-items:center">
        <button id="test-grade" class="primary hidden">Calificar</button>
        <button id="test-reset" class="ghost hidden">Nuevo</button>
        <span class="pill" id="test-score"></span>
      </div>
      <div id="test-report" class="panel hidden" style="margin-top:12px">
        <h4 style="margin:0 0 8px 0">Reporte</h4>
        <div class="row" style="gap:12px; flex-wrap:wrap">
          <span class="pill" id="rep-total">‚Äî</span>
          <span class="pill" id="rep-mcq">‚Äî</span>
          <span class="pill" id="rep-tf">‚Äî</span>
          <span class="pill" id="rep-short">‚Äî</span>
        </div>
        <div class="chart" id="report-chart"></div>
      </div>
    </section>

    <!-- Memory match view -->
    <section id="view-match" class="panel hidden">
      <div class="row space-between">
        <h3 class="section-title">Memorama</h3>
        <div class="row" style="gap:6px; flex-wrap:wrap">
          <select id="select-match"></select>
          <label class="pill">Pares <input id="match-count" type="number" value="8" min="2" style="width:60px; margin-left:6px"></label>
          <button id="match-start" class="primary">Iniciar</button>
        </div>
      </div>
      <div id="match-area" class="match-grid" style="grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); margin-top:12px"></div>
      <div id="match-info" class="row" style="gap:8px; margin-top:8px">
        <span class="pill" id="match-moves">Movimientos: 0</span>
        <span class="pill" id="match-progress">0/0</span>
      </div>
    </section>

    <!-- Pair matching game (Parear) -->
    <section id="view-pair" class="panel hidden">
      <div class="row space-between">
        <h3 class="section-title">Parear</h3>
        <div class="row" style="gap:6px; flex-wrap:wrap">
          <select id="select-pair"></select>
          <label class="pill">Pares <input id="pair-count" type="number" value="5" min="2" style="width:60px; margin-left:6px"></label>
          <button id="pair-start" class="primary">Iniciar</button>
        </div>
      </div>
      <div id="pair-area" class="grid" style="grid-template-columns: 1fr 1fr; gap:12px; margin-top:12px"></div>
      <div id="pair-info" class="row" style="gap:8px; margin-top:8px">
        <span class="pill" id="pair-progress">0/0</span>
      </div>
    </section>

    <!-- Combination game (Combinar) -->
    <section id="view-comb" class="panel hidden">
      <div class="row space-between">
        <h3 class="section-title">Combinar</h3>
        <div class="row" style="gap:6px; flex-wrap:wrap">
          <select id="select-comb"></select>
          <label class="pill">Pares <input id="comb-count" type="number" value="5" min="2" style="width:60px; margin-left:6px"></label>
          <button id="comb-start" class="primary">Iniciar</button>
        </div>
      </div>
      <div id="comb-area" class="grid" style="grid-template-columns: 1fr 1fr; gap:12px; margin-top:12px"></div>
      <div id="comb-info" class="row" style="gap:8px; margin-top:8px">
        <span class="pill" id="comb-progress">0/0</span>
      </div>
    </section>

    <!-- Cloze + Elaboraci√≥n view -->
    <section id="view-cloze" class="panel hidden">
      <div class="row space-between">
        <h3 class="section-title">Elaborar</h3>
        <div class="row" style="gap:6px; flex-wrap:wrap">
          <select id="select-cloze"></select>
          <button id="cloze-start" class="primary">Iniciar</button>
        </div>
      </div>
      <div id="cloze-card" style="margin-top:12px"></div>
      <div class="row" style="gap:8px; margin-top:8px">
        <span class="pill" id="cloze-progress">0/0</span>
      </div>
    </section>

    <!-- Import/Export view -->
    <section id="view-import" class="panel hidden">
      <h3 class="section-title">Importar / Exportar</h3>
      <div class="grid cols-2">
        <div>
          <h4>Importar CSV/JSON</h4>
          <input type="file" id="file-input" accept=".csv,.json" />
          <p class="muted">CSV con encabezados: set_title, term, definition, extra_notes, tags, lang_term, lang_definition, difficulty</p>
          <button id="btn-import" class="primary" disabled>Importar</button>
          <div id="import-preview" class="muted" style="margin-top:8px"></div>
        </div>
        <div>
          <h4>Exportar</h4>
          <div class="row" style="gap:8px; flex-wrap:wrap">
            <select id="export-select"></select>
            <button id="btn-export-json">Exportar JSON</button>
            <button id="btn-export-csv">Exportar CSV</button>
            <button id="btn-backup" class="ghost">Respaldar (archivo .json)</button>
          </div>
        </div>
      </div>
      <hr style="border-color:var(--border); margin:16px 0" />
      <h4>Datos en LocalStorage</h4>
      <div class="row" style="gap:8px">
        <span class="pill">Clave: <code style="font-family: ui-monospace">penguQuizlet:v5</code></span>
        <button id="btn-dump" class="ghost">Ver JSON</button>
        <button id="btn-restore" class="warn">Restaurar desde JSON</button>
      </div>
      <textarea id="dump-area" rows="8" style="width:100%; margin-top:8px; font-family: ui-monospace"></textarea>
    </section>
  </div>

  <!-- Modal for creating new sets -->
  <div class="scrim" id="scrim">
    <div class="modal">
      <h3>Nuevo set</h3>
      <div class="grid">
        <input id="new-title" placeholder="T√≠tulo del set" />
        <textarea id="new-desc" rows="2" placeholder="Descripci√≥n (opcional)"></textarea>
        <!-- Folder selector: populated dynamically with existing folders -->
        <select id="new-folder-select">
          <option value="">Sin carpeta</option>
        </select>
      </div>
      <div class="row" style="gap:8px; margin-top:10px; justify-content:flex-end">
        <button id="modal-cancel" class="ghost">Cancelar</button>
        <button id="modal-ok" class="primary">Crear</button>
      </div>
    </div>
  </div>

  <!-- Modal for adding multiple cards -->
  <div class="scrim" id="scrim-cards">
    <div class="modal">
      <h3>A√±adir tarjetas</h3>
      <div id="multi-form" class="list"></div>
      <div class="row" style="gap:8px; margin-top:8px">
        <button id="btn-add-row" class="ghost">A√±adir fila</button>
      </div>
      <div class="row" style="gap:8px; margin-top:10px; justify-content:flex-end">
        <button id="btn-cancel-cards" class="ghost">Cancelar</button>
        <button id="btn-save-cards" class="primary">Guardar</button>
      </div>
    </div>
  </div>

  <!-- Modal for creating new folders -->
  <div class="scrim" id="scrim-folder">
    <div class="modal">
      <h3>Nueva carpeta</h3>
      <div class="grid">
        <input id="folder-name" placeholder="Nombre de la carpeta" />
      </div>
      <div class="row" style="gap:8px; margin-top:10px; justify-content:flex-end">
        <button id="folder-cancel" class="ghost">Cancelar</button>
        <button id="folder-ok" class="primary">Crear</button>
      </div>
    </div>
  </div>

  <script>
  // === Utility functions ===
  const qs = sel => document.querySelector(sel);
  const el = (tag, props = {}) => { const e = document.createElement(tag); Object.assign(e, props); return e; };
  const nowISO = () => new Date().toISOString();
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));

  // Robust CSV parser: returns array of rows, ignoring completely empty rows
  function parseCSV(csv) {
    const rows = [];
    if (!csv) return rows;
    const lines = csv.trim().split(/\r?\n/);
    lines.forEach(line => {
      const cells = [];
      let cell = '';
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        const next = line[i + 1];
        if (ch === '"' && next === '"') {
          cell += '"';
          i++;
        } else if (ch === '"') {
          inQuotes = !inQuotes;
        } else if (ch === ',' && !inQuotes) {
          cells.push(cell);
          cell = '';
        } else {
          cell += ch;
        }
      }
      cells.push(cell);
      const trimmed = cells.map(c => (c || '').trim());
      if (trimmed.some(c => c !== '')) rows.push(trimmed);
    });
    return rows;
  }

  // Utility to trigger downloads for export (CSV/JSON). Creates a blob and triggers a hidden anchor click.
  function download(filename, data, mime) {
    const blob = new Blob([data], { type: mime || 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 0);
  }

  // Confetti effect for positive feedback
  (function(){
    const canvas = qs('#confetti');
    const ctx = canvas.getContext('2d');
    let W = 0, H = 0, parts = [], running = false;
    const colors = [ '#ff76b9', '#ffa6cf', '#ffd1e8', '#fff' ];
    function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize); resize();
    window.confettiLaunch = function(n = 120) {
      for (let i = 0; i < n; i++) {
        parts.push({
          x: Math.random() * W,
          y: -10,
          size: 6 + Math.random() * 6,
          vy: 2 + Math.random() * 2,
          vx: (Math.random() - 0.5) * 2,
          rot: Math.random() * 6.28,
          color: colors[i % colors.length]
        });
      }
      if (!running) {
        running = true;
        requestAnimationFrame(loop);
      }
      setTimeout(() => {
        parts = [];
        running = false;
        ctx.clearRect(0, 0, W, H);
      }, 1200);
    };
    function loop() {
      if (!running) return;
      ctx.clearRect(0, 0, W, H);
      parts.forEach(p => {
        p.y += p.vy;
        p.x += p.vx;
        p.rot += 0.1;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
        ctx.restore();
      });
      requestAnimationFrame(loop);
    }
  })();

  // === Storage layer ===
  const STORAGE_KEY = 'penguQuizlet:v5';
// Database structure now also tracks folders for organizing sets
let db = { sets: {}, items: {}, progress: {}, folders: {} };
  function load() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) {
        const parsed = JSON.parse(raw);
        db.sets = parsed.sets || {};
        db.items = parsed.items || {};
        db.progress = parsed.progress || {};
        // Load folders if present
        db.folders = parsed.folders || {};
      }
    } catch (e) {
      console.warn('Load failed', e);
    }
  }
  function save() {
    // Persist folders along with sets, items and progress
    localStorage.setItem(STORAGE_KEY, JSON.stringify(db));
  }
  function uuid() {
    return 'xxxxxxxx'.replace(/x/g, () => (Math.random() * 16 | 0).toString(16));
  }

  // === State ===
  let currentSet = null;
  let flashState = { order: [], index: 0, reversed: false };
  let currentTest = null;
  let matchState = null;

  // Autoplay state for flashcards
  let flashAuto = false;
  let flashAutoTimer = null;
  let flashAutoFlipped = false;

  // Timer for learn feedback delay
  let learnTimer = null;

  // Pair and combination games state
  let pairState = null;
  let combState = null;

  // Multi-card modal state
  let multiSetId = null;

  // === Render sets and progress ===
  function renderSetProgress(setId) {
    const items = db.items[setId] || [];
    const prog = db.progress[setId] || {};
    const mastered = items.filter(it => (prog[it.id] && prog[it.id].bucket >= 5)).length;
    if (!items.length) return '';
    const mastery = prog.mastery != null ? prog.mastery : 0;
    return `${mastered}/${items.length} dominadas ¬∑ ${mastery}% dominio`;
  }
  function renderSets() {
    const list = qs('#sets-list');
    list.innerHTML = '';
    const ids = Object.keys(db.sets);
    if (!ids.length) {
      list.appendChild(el('div', { className: 'muted', innerText: 'A√∫n no tienes sets. Importa un CSV/JSON o crea uno nuevo.' }));
      return;
    }
    // Group sets by folder (use empty string for no folder)
    const groups = {};
    ids.forEach(id => {
      const s = db.sets[id];
      const fid = s.folder || '';
      if (!groups[fid]) groups[fid] = [];
      groups[fid].push(id);
    });
    // Sort folder keys: folders alphabetically, unfiled last
    const fids = Object.keys(groups).sort((a,b) => {
      if (a === '' && b !== '') return 1;
      if (b === '' && a !== '') return -1;
      const an = a && db.folders[a] ? db.folders[a].name.toLowerCase() : '';
      const bn = b && db.folders[b] ? db.folders[b].name.toLowerCase() : '';
      return an.localeCompare(bn);
    });
    fids.forEach(fid => {
      const headerName = fid && db.folders[fid] ? db.folders[fid].name : 'Sin carpeta';
      const header = el('div', { className:'muted', innerText: headerName, style:'font-weight:600;margin-top:8px' });
      list.appendChild(header);
      groups[fid].forEach(id => {
        const s = db.sets[id];
        const items = db.items[id] || [];
        const row = el('div', { className: 'item' });
        // Top row with title, count, progress and actions
        const top = el('div', { className: 'row space-between' });
        const left = el('div');
        const prog = renderSetProgress(id);
        left.innerHTML = `<strong>${s.title}</strong> <span class="muted">(${items.length} tarjetas)</span>` + (prog ? ` <span class="pill" style="margin-left:4px">${prog}</span>` : '');
        top.appendChild(left);
        const actions = el('div', { className: 'row', style: 'gap:8px; flex-wrap:wrap' });
        const btnStudy = el('button', { innerText: 'Abrir' });
        btnStudy.onclick = () => { currentSet = id; syncSelectors(); switchView('flash'); initFlash(); };
        const btnEdit = el('button', { innerText: 'A√±adir tarjeta', className: 'ghost' });
        btnEdit.onclick = () => { addCardPrompt(id); };
        const btnDelete = el('button', { innerText: 'Eliminar', className: 'danger' });
        btnDelete.onclick = () => {
          if (confirm('¬øEliminar set y tarjetas?')) {
            delete db.sets[id];
            delete db.items[id];
            delete db.progress[id];
            save();
            renderAll();
          }
        };
        actions.appendChild(btnStudy);
        actions.appendChild(btnEdit);
        actions.appendChild(btnDelete);
        top.appendChild(actions);
        row.appendChild(top);
        // Description
        if (s.description) row.appendChild(el('div', { className: 'muted', innerText: s.description }));
        // Folder selection row
        const folderRow = el('div', { className:'row', style:'gap:8px; margin-top:4px; flex-wrap:wrap; align-items:center' });
        folderRow.appendChild(el('small', { className:'muted', innerText:'Carpeta:' }));
        const fs = el('select', { style:'min-width:140px' });
        fs.appendChild(el('option', { value:'', innerText:'Sin carpeta' }));
        Object.values(db.folders).forEach(fobj => {
          const opt = el('option', { value:fobj.id, innerText:fobj.name });
          if (s.folder && s.folder === fobj.id) opt.selected = true;
          fs.appendChild(opt);
        });
        fs.onchange = () => {
          s.folder = fs.value || null;
          db.sets[id] = s;
          save();
          renderSets();
        };
        folderRow.appendChild(fs);
        row.appendChild(folderRow);
        list.appendChild(row);
      });
    });
  }

  // === Sync selectors ===
  function syncSelectors() {
    let options = '';
    Object.values(db.sets).forEach(s => {
      options += `<option value="${s.id}"${s.id === currentSet ? ' selected' : ''}>${s.title}</option>`;
    });
    ['select-flash','select-learn','select-test','select-match','select-pair','select-comb','select-cloze','select-leelo'].forEach(id => {
      const select = qs('#' + id);
      if (select) select.innerHTML = options;
    });
    // populate export select with an option for all sets plus each set
    const exportSel = qs('#export-select');
    if (exportSel) {
      let opts = '<option value="">Todos los sets</option>';
      Object.values(db.sets).forEach(s => {
        opts += `<option value="${s.id}">${s.title}</option>`;
      });
      exportSel.innerHTML = opts;
    }
  }

  // === Flashcards ===
  function initFlash() {
    const sel = qs('#select-flash');
    const setId = sel.value || currentSet;
    if (!setId) return;
    currentSet = setId;
    const items = (db.items[setId] || []).slice();
    flashState.order = items.map((_, i) => i);
    flashState.index = 0;
    renderFlash();
  }
  function renderFlash() {
    const items = db.items[currentSet] || [];
    const inner = qs('#flash-inner');
    if (!items.length) {
      qs('#flash-front').innerText = '(vac√≠o)';
      qs('#flash-back').innerText = 'Agrega tarjetas';
      return;
    }
    const i = flashState.order[flashState.index];
    const it = items[i];
    // Determine content for front and back. Only show image on definition side
    let frontContent = flashState.reversed ? it.definition : it.term;
    let backContent = flashState.reversed ? it.term : it.definition;
    if (it.image) {
      if (flashState.reversed) {
        // definition shown on front
        frontContent += `<br><img src="${it.image}" class="card-image" />`;
      } else {
        // definition on back
        backContent += `<br><img src="${it.image}" class="card-image" />`;
      }
    }
    qs('#flash-front').innerHTML = frontContent;
    qs('#flash-back').innerHTML = backContent;
    inner.classList.remove('flipped');
  }
  function flashFlip() {
    qs('#flash-inner').classList.toggle('flipped');
  }
  function flashPrev() {
    const len = flashState.order.length;
    if (!len) return;
    flashState.index = (flashState.index - 1 + len) % len;
    renderFlash();
  }
  function flashNext() {
    const len = flashState.order.length;
    if (!len) return;
    flashState.index = (flashState.index + 1) % len;
    renderFlash();
  }
  function handleTouchStart(e) { window._sx = e.touches[0].clientX; }
  function handleTouchMove(e) { window._dx = e.touches[0].clientX - window._sx; }
  function handleTouchEnd() {
    if (Math.abs(window._dx) > 60) {
      if (window._dx > 0) flashPrev(); else flashNext();
    }
    window._dx = 0;
  }

  // === Learn (adaptive) ===
  const BASE_INTERVALS = [0, 1, 3, 7, 14];
  function ensureProgress(setId) {
    db.progress[setId] = db.progress[setId] || {};
    (db.items[setId] || []).forEach(it => {
      if (!db.progress[setId][it.id]) {
        db.progress[setId][it.id] = {
          ef: 2.3,
          bucket: 1,
          seen: 0,
          correct: 0,
          streak: 0,
          lastSeen: null,
          nextDue: null
        };
      }
    });
  }
  function pickLearnItem(setId) {
    ensureProgress(setId);
    const items = db.items[setId] || [];
    const p = db.progress[setId];
    const nowT = Date.now();
    const due = [], fresh = [], rest = [];
    items.forEach(it => {
      const pr = p[it.id];
      const dueAt = pr.nextDue ? new Date(pr.nextDue).getTime() : 0;
      if (!pr.seen) fresh.push(it);
      else if (!pr.nextDue || nowT >= dueAt) due.push(it);
      else rest.push(it);
    });
    const pool = due.length ? due : (fresh.length ? fresh : rest);
    if (!pool.length) return null;
    const it = pool[Math.floor(Math.random() * pool.length)];
    return buildLearnQuestion(it);
  }
  function buildLearnQuestion(item) {
    const modeSel = qs('#learn-mode').value;
    const dirSel = qs('#learn-direction').value;
    const kind = modeSel === 'mix' ? ['mcq','type','judge'][Math.floor(Math.random() * 3)] : modeSel;
    const setItems = db.items[currentSet] || [];
    const q = { id: item.id, kind: kind, prompt: item.term, answer: item.definition, choices: [], direction: 'def' };
    if (dirSel === 'term') {
      q.prompt = item.definition;
      q.answer = item.term;
      q.direction = 'term';
    } else if (dirSel === 'auto') {
      if (Math.random() < 0.5) {
        q.prompt = item.term;
        q.answer = item.definition;
        q.direction = 'def';
      } else {
        q.prompt = item.definition;
        q.answer = item.term;
        q.direction = 'term';
      }
    }
    if (kind === 'mcq') {
      // Build 5 options: one correct and up to four incorrect
      let wrong = setItems.filter(x => x.id !== item.id).map(x => (q.direction === 'term' ? x.term : x.definition));
      wrong = wrong.sort(() => Math.random() - 0.5);
      const pool = wrong.slice(0, 4);
      // If there are fewer than 4 distractors, repeat random ones
      while (pool.length < 4) {
        const extra = wrong[Math.floor(Math.random() * Math.max(1, wrong.length))];
        pool.push(extra);
      }
      const correct = q.answer;
      const ch = [correct].concat(pool).sort(() => Math.random() - 0.5);
      q.choices = ch;
      q.correctIndex = ch.indexOf(correct);
    }
    if (kind === 'judge') {
      const showCorrect = Math.random() < 0.5;
      const other = setItems[Math.floor(Math.random() * setItems.length)];
      const shown = showCorrect ? q.answer : (q.direction === 'term' ? other.term : other.definition);
      q.shown = shown;
      q.truth = (shown === q.answer);
    }
    return q;
  }
  function gradeLearn(itemId, quality) {
    const pr = db.progress[currentSet][itemId];
    pr.seen++;
    pr.lastSeen = nowISO();
    if (quality >= 4) {
      pr.correct++;
      pr.streak++;
      pr.bucket = clamp(pr.bucket + 1, 1, 5);
      pr.ef = Math.max(1.3, pr.ef + 0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
    } else {
      pr.streak = 0;
      pr.bucket = clamp(pr.bucket - 1, 1, 5);
      pr.ef = Math.max(1.3, pr.ef - 0.15);
    }
    const base = BASE_INTERVALS[pr.bucket - 1];
    const days = base * (pr.ef / 2.3);
    pr.nextDue = new Date(Date.now() + days * 24 * 3600 * 1000).toISOString();
    save();

    // Update mastery score for the current set after grading
    computeMastery(currentSet);
  }

  // Compute mastery for a set based on spaced repetition progress and test scores
  function computeMastery(setId) {
    if (!setId) return;
    const items = db.items[setId] || [];
    const p = db.progress[setId] || {};
    // average bucket progress (1-5)
    let sumBuckets = 0;
    items.forEach(it => {
      const pr = p[it.id] || { bucket: 1 };
      sumBuckets += pr.bucket;
    });
    const learnScore = items.length ? sumBuckets / (5 * items.length) : 0;
    // average test scores stored in progress
    const tests = p.tests || [];
    let testScore = 0;
    if (tests.length) {
      let sum = 0;
      tests.forEach(t => { sum += t.score; });
      testScore = (sum / tests.length) / 100;
    }
    // Weighted mastery: 60% learn progress + 40% test average
    const mastery = Math.round((learnScore * 0.6 + testScore * 0.4) * 100);
    p.mastery = mastery;
    db.progress[setId] = p;
    save();
  }
  function renderLearn() {
    const setId = qs('#select-learn').value || currentSet;
    const area = qs('#learn-stage');
    if (!setId) {
      area.innerHTML = '';
      qs('#learn-progress').style.width = '0%';
      qs('#learn-stats').innerText = 'Sin tarjetas';
      return;
    }
    currentSet = setId;
    ensureProgress(setId);
    const items = db.items[setId] || [];
    const p = db.progress[setId] || {};
    // Compute progress: consider an item learned when it has advanced to at least bucket 3.
    let learned = 0;
    items.forEach(it => {
      const pr = p[it.id];
      // Count as learned when the item reaches bucket >=2 (at least one correct attempt)
      if (pr && pr.bucket >= 2) learned++;
    });
    const pct = items.length ? Math.round(100 * learned / items.length) : 0;
    qs('#learn-progress').style.width = pct + '%';
    qs('#learn-stats').innerText = items.length ? `${learned}/${items.length} aprendidas` : 'Sin tarjetas';
    const q = pickLearnItem(setId);
    area.innerHTML = '';
    if (!q) {
      area.appendChild(el('div', { className: 'muted', innerText: 'No hay elementos para practicar.' }));
      return;
    }
    // Cancel any pending delay
    if (learnTimer) { clearTimeout(learnTimer); learnTimer = null; }
    currentLearnQ = q;
    // Render question card depending on type
    if (q.kind === 'mcq') {
      const card = el('div', { className: 'item learn-card' });
      card.appendChild(el('div', { className: 'term', innerText: q.prompt }));
      // Append image if item has one
      const it = (db.items[setId] || []).find(x => x.id === q.id);
      if (it && it.image) {
        card.appendChild(el('img', { className:'learn-image', src: it.image }));
      }
      q.choices.forEach((c, idx) => {
        const b = el('button', { className: 'item', style:'display:block;width:100%;text-align:left;margin-top:4px;', innerText: c });
        b.onclick = () => {
          const correct = (idx === q.correctIndex);
          handleLearnAnswer(correct, q);
        };
        card.appendChild(b);
      });
      area.appendChild(card);
    } else if (q.kind === 'type') {
      const card2 = el('div', { className: 'item learn-card' });
      const label = q.direction === 'term' ? 'Escribe el T√âRMINO: ' : 'Escribe la DEFINICI√ìN: ';
      card2.appendChild(el('div', { className: 'term', innerText: label + q.prompt }));
      // Append image if item has one
      const it2 = (db.items[setId] || []).find(x => x.id === q.id);
      if (it2 && it2.image) {
        card2.appendChild(el('img', { className:'learn-image', src: it2.image }));
      }
      const inp = el('input', { placeholder: q.direction === 'term' ? 'T√©rmino...' : 'Definici√≥n...', style:'margin-top:8px' });
      const res = el('div', { className: 'muted', style:'margin-top:8px' });
      const btn = el('button', { className: 'primary', innerText: 'Comprobar', style:'margin-top:8px' });
      btn.onclick = () => {
        // prevent multiple submissions
        if (btn.disabled) return;
        btn.disabled = true;
        inp.disabled = true;
        const guessRaw = (inp.value || '').trim().toLowerCase();
        const ansRaw = (q.answer || '').trim().toLowerCase();
        const guess = stripAccents(guessRaw);
        const ans = stripAccents(ansRaw);
        const ok = levenshtein(guess, ans) <= Math.max(1, Math.floor(ans.length * 0.1));
        res.innerText = ok ? '‚úì Correcto' : `‚úó Incorrecto. Resp.: ${q.answer}`;
        handleLearnAnswer(ok, q);
      };
      card2.appendChild(inp);
      card2.appendChild(btn);
      card2.appendChild(res);
      area.appendChild(card2);
    } else if (q.kind === 'judge') {
      const card3 = el('div', { className: 'item learn-card' });
      card3.appendChild(el('div', { className: 'term', innerText: q.prompt }));
      // Append image if item has one
      const it3 = (db.items[setId] || []).find(x => x.id === q.id);
      if (it3 && it3.image) {
        card3.appendChild(el('img', { className:'learn-image', src: it3.image }));
      }
      card3.appendChild(el('div', { className: 'def', innerText: q.shown, style:'margin-top:6px' }));
      const row = el('div', { className: 'row', style:'gap:8px;margin-top:8px' });
      const b1 = el('button', { className: 'primary', innerText:'Verdadero' });
      b1.onclick = () => {
        const ok = q.truth;
        handleLearnAnswer(ok, q);
      };
      const b2 = el('button', { className:'ghost', innerText:'Falso' });
      b2.onclick = () => {
        const ok = !q.truth;
        handleLearnAnswer(ok, q);
      };
      row.appendChild(b1);
      row.appendChild(b2);
      card3.appendChild(row);
      area.appendChild(card3);
    }
  }

  // Current learn question reference
  let currentLearnQ = null;
  // Handle learn answer: grade, feedback, delay and next button
  function handleLearnAnswer(isCorrect, q) {
    // grade the item
    gradeLearn(q.id, isCorrect ? 5 : 2);
    if (isCorrect) window.confettiLaunch(140);
    // Build feedback area
    const area = qs('#learn-stage');
    const feedback = el('div', { className:'muted', style:'margin-top:12px' });
    feedback.innerText = isCorrect ? '‚úì Correcto' : `‚úó Incorrecto. Resp.: ${q.answer}`;
    area.appendChild(feedback);
    // Create next button
    const nextBtn = el('button', { className:'ghost', innerText:'Siguiente', style:'margin-top:8px' });
    nextBtn.onclick = () => {
      clearTimeout(learnTimer);
      learnTimer = null;
      renderLearn();
    };
    area.appendChild(nextBtn);
    // Schedule auto-advance in 10 seconds
    learnTimer = setTimeout(() => {
      learnTimer = null;
      renderLearn();
    }, 10000);
  }
  function levenshtein(a, b) {
    if (a === b) return 0;
    const an = a.length, bn = b.length;
    if (!an) return bn;
    if (!bn) return an;
    const arr = new Array(bn + 1);
    for (let i = 0; i <= bn; i++) arr[i] = i;
    for (let i = 1; i <= an; i++) {
      let prev = i;
      for (let j = 1; j <= bn; j++) {
        const tmp = arr[j];
        const val = a.charAt(i - 1) === b.charAt(j - 1) ? arr[j - 1] : Math.min(arr[j - 1] + 1, prev + 1, arr[j] + 1);
        arr[j] = val;
        prev = tmp;
      }
      arr[0] = i;
    }
    return arr[bn];
  }

  // Remove diacritics from a string to allow accent-insensitive comparisons
  function stripAccents(str) {
    return (str || '').normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  }

  // === Test/Probar ===
  function genTest() {
    const setId = qs('#select-test').value || currentSet;
    if (!setId) return;
    currentSet = setId;
    const items = (db.items[setId] || []).slice();
    const n = clamp(parseInt(qs('#test-count').value || '10', 10), 5, 200);
    const mix = qs('#test-mode').value;
    if (items.length < 2) { alert('Se requieren ‚â• 2 tarjetas.'); return; }
    const kinds = (mix === 'balanced') ? ['mcq','tf','short'] : (mix === 'mcq' ? ['mcq'] : (mix === 'tf' ? ['tf'] : ['short']));
    const qsArr = [];
    for (let i = 0; i < n; i++) {
      const it = items[Math.floor(Math.random() * items.length)];
      const kind = kinds[i % kinds.length];
      if (kind === 'mcq') {
        // build 5 options: one correct and up to four incorrect
        let wrong = items.filter(x => x.id !== it.id).map(x => x.definition);
        wrong = wrong.sort(() => Math.random() - 0.5);
        const pool = wrong.slice(0, 4);
        while (pool.length < 4) {
          const extra = wrong[Math.floor(Math.random() * Math.max(1, wrong.length))];
          pool.push(extra);
        }
        const ch = [it.definition].concat(pool).sort(() => Math.random() - 0.5);
        qsArr.push({ kind:'mcq', prompt: it.term, choices: ch, answer: it.definition, correctIndex: ch.indexOf(it.definition) });
      } else if (kind === 'tf') {
        const other = items[Math.floor(Math.random() * items.length)].definition;
        const truth = Math.random() < 0.5;
        const shown = truth ? it.definition : other;
        qsArr.push({ kind:'tf', prompt: it.term, shown: shown, truth: truth });
      } else {
        // For respuesta corta, mostrar definici√≥n y esperar el t√©rmino
        qsArr.push({ kind:'short', prompt: it.definition, answer: it.term });
      }
    }
    currentTest = { setId: setId, qs: qsArr, answers: [], graded: false, score: null };
    renderTest();
  }
  function renderTest() {
    const area = qs('#test-area');
    area.innerHTML = '';
    qs('#test-report').classList.add('hidden');
    if (!currentTest) {
      qs('#test-grade').classList.add('hidden');
      qs('#test-reset').classList.add('hidden');
      qs('#test-score').innerText = '';
      return;
    }
    currentTest.qs.forEach((q, idx) => {
      const card = el('div', { className: 'item' });
      card.id = 'qcard_' + idx;
      card.appendChild(el('div', { className: 'term', innerText: `${idx + 1}. ${q.prompt}` }));
      // Append image if this item has one (only for definition side)
      const itemsList = db.items[currentSet] || [];
      let imgItem = null;
      if (q.kind === 'short') {
        // q.answer holds the term
        imgItem = itemsList.find(x => x.term === q.answer);
      } else {
        // q.prompt holds the term
        imgItem = itemsList.find(x => x.term === q.prompt);
      }
      if (imgItem && imgItem.image) {
        card.appendChild(el('img', { className:'test-image', src: imgItem.image }));
      }
      if (q.kind === 'mcq') {
        q.choices.forEach((c, i) => {
          const id = `q${idx}_c${i}`;
          const row = el('div', { className: 'row', style: 'gap:6px' });
          const input = el('input', { type:'radio', name:'q' + idx, id:id });
          input.onchange = () => { currentTest.answers[idx] = { type:'mcq', value:i }; };
          const label = el('label', { htmlFor:id, innerText: c });
          row.appendChild(input);
          row.appendChild(label);
          card.appendChild(row);
        });
      } else if (q.kind === 'tf') {
        ['Verdadero','Falso'].forEach((lab,i) => {
          const id = `q${idx}_tf${i}`;
          const row = el('div', { className: 'row', style: 'gap:6px' });
          const input = el('input', { type:'radio', name:'q' + idx, id:id });
          input.onchange = () => { currentTest.answers[idx] = { type:'tf', value:(i === 0) }; };
          const label = el('label', { htmlFor:id, innerText: lab });
          row.appendChild(input);
          row.appendChild(label);
          card.appendChild(row);
        });
        // Show the statement without a prefix for cleaner true/false questions
        card.appendChild(el('div', { className: 'def', innerText: q.shown, style:'margin-top:6px' }));
      } else {
        const inp = el('input', { placeholder:'Respuesta corta' });
        inp.oninput = () => { currentTest.answers[idx] = { type:'short', value: inp.value }; };
        card.appendChild(inp);
      }
      area.appendChild(card);
    });
    qs('#test-grade').classList.remove('hidden');
    qs('#test-reset').classList.add('hidden');
    qs('#test-score').innerText = '';
  }
  function gradeTest() {
    let correct = 0;
    const byType = { mcq:{ ok:0, all:0 }, tf:{ ok:0, all:0 }, short:{ ok:0, all:0 } };
    ensureProgress(currentSet);
    const items = db.items[currentSet] || [];
    currentTest.qs.forEach((q,i) => {
      const ans = currentTest.answers[i];
      let ok = false;
      if (q.kind === 'mcq') {
        byType.mcq.all++;
        ok = ans && q.correctIndex === ans.value;
      } else if (q.kind === 'tf') {
        byType.tf.all++;
        ok = ans && ans.value === !!q.truth;
      } else {
        byType.short.all++;
        const guessRaw = (ans ? ans.value : '').trim().toLowerCase();
        const realRaw = (q.answer || '').trim().toLowerCase();
        const guess = stripAccents(guessRaw);
        const real = stripAccents(realRaw);
        ok = levenshtein(guess, real) <= Math.max(1, Math.floor(real.length * 0.1));
      }
      if (ok) {
        correct++;
        byType[q.kind].ok++;
      }
      const card = qs('#qcard_' + i);
      if (ok) card.classList.add('correct'); else card.classList.add('incorrect');
      const info = el('div', { className:'muted' });
      if (q.kind === 'mcq') {
        info.innerText = 'Respuesta correcta: ' + q.answer;
      } else if (q.kind === 'tf') {
        info.innerText = 'Era ' + (q.truth ? 'Verdadero' : 'Falso');
      } else {
        info.innerText = 'Respuesta correcta: ' + q.answer;
      }
      card.appendChild(info);
      const item = items.find(x => x.term === q.prompt);
      if (item) gradeLearn(item.id, ok ? 5 : 2);
    });
    const score = Math.round(100 * correct / currentTest.qs.length);
    currentTest.graded = true;
    currentTest.score = score;
    // Store test score in progress for mastery computation
    const pr = db.progress[currentSet] || {};
    pr.tests = pr.tests || [];
    pr.tests.push({ score: score, date: nowISO() });
    // keep only last 5 tests
    if (pr.tests.length > 5) pr.tests.shift();
    db.progress[currentSet] = pr;
    save();
    qs('#test-score').innerText = `Puntaje: ${score}% (${correct}/${currentTest.qs.length})`;
    qs('#test-grade').classList.add('hidden');
    qs('#test-reset').classList.remove('hidden');
    qs('#test-report').classList.remove('hidden');
    // Update mastery based on new test
    computeMastery(currentSet);
    function pct(t) { return t.all ? Math.round(100 * t.ok / t.all) : 0; }
    qs('#rep-total').innerText = 'Total: ' + score + '%';
    qs('#rep-mcq').innerText = 'MCQ: ' + pct(byType.mcq) + '% (' + byType.mcq.ok + '/' + byType.mcq.all + ')';
    qs('#rep-tf').innerText = 'V/F: ' + pct(byType.tf) + '% (' + byType.tf.ok + '/' + byType.tf.all + ')';
    qs('#rep-short').innerText = 'Corta: ' + pct(byType.short) + '% (' + byType.short.ok + '/' + byType.short.all + ')';
    renderChart({ mcq:pct(byType.mcq), tf:pct(byType.tf), short:pct(byType.short) });
    if (score >= 80) window.confettiLaunch(180);
  }
  function renderChart(data) {
    const chart = qs('#report-chart');
    chart.innerHTML = '';
    const max = 100;
    function addBar(label, val) {
      const h = (val / max) * 120 + 10;
      const bar = el('div', { className:'bar' });
      bar.style.height = h + 'px';
      const cap = el('div', { className:'label', innerText: label.toUpperCase() + ': ' + val + '%' });
      bar.appendChild(cap);
      chart.appendChild(bar);
    }
    addBar('mcq', data.mcq);
    addBar('v/f', data.tf);
    addBar('corta', data.short);
  }

  // === Match / Memorama ===
  function startMatch() {
    const setId = qs('#select-match').value || currentSet;
    if (!setId) return;
    currentSet = setId;
    const items = (db.items[setId] || []).slice();
    if (items.length < 2) { alert('Se requieren ‚â• 2 tarjetas.'); return; }
    // Determine number of pairs to use
    const countInput = qs('#match-count');
    let count = items.length;
    if (countInput) {
      const v = parseInt(countInput.value);
      if (!isNaN(v) && v > 0) count = Math.min(v, items.length);
    }
    // Select random subset of items
    const selected = items.slice().sort(() => Math.random() - 0.5).slice(0, count);
    const pairs = [];
    selected.forEach(it => {
      pairs.push({ type:'term', text: it.term, id: it.id });
      pairs.push({ type:'def', text: it.definition, id: it.id });
    });
    // Shuffle pairs
    pairs.sort(() => Math.random() - 0.5);
    matchState = { moves: 0, matched: 0, opened: [], pairs: pairs };
    renderMatch();
  }
  function renderMatch() {
    if (!matchState) return;
    const grid = qs('#match-area');
    grid.innerHTML = '';
    qs('#match-moves').innerText = 'Movimientos: ' + matchState.moves;
    qs('#match-progress').innerText = matchState.matched + '/' + matchState.pairs.length;
    matchState.pairs.forEach((p, idx) => {
      const card = el('div', { className:'match-card' });
      card.dataset.index = idx;
      if (matchState.opened.includes(idx) || p.matched) {
        card.classList.add(p.matched ? 'matched' : 'revealed');
        card.innerText = p.text;
      } else {
        card.innerText = '?';
      }
      card.onclick = () => {
        if (p.matched || matchState.opened.includes(idx)) return;
        matchState.opened.push(idx);
        if (matchState.opened.length === 2) {
          matchState.moves++;
          const first = matchState.opened[0];
          const second = matchState.opened[1];
          if (matchState.pairs[first].id === matchState.pairs[second].id && matchState.pairs[first].type !== matchState.pairs[second].type) {
            matchState.pairs[first].matched = true;
            matchState.pairs[second].matched = true;
            matchState.matched += 2;
            if (matchState.matched === matchState.pairs.length) window.confettiLaunch(200);
            // grade matched item as correct once
            gradeLearn(matchState.pairs[first].id, 5);
          }
          setTimeout(() => { matchState.opened = []; renderMatch(); }, 650);
        }
        renderMatch();
      };
      grid.appendChild(card);
    });
  }

  // === Pair (Parear) game ===
  function startPair() {
    const setId = qs('#select-pair').value || currentSet;
    if (!setId) return;
    currentSet = setId;
    const items = (db.items[setId] || []).slice();
    if (items.length < 2) { alert('Se requieren ‚â• 2 tarjetas.'); return; }
    let count = items.length;
    const input = qs('#pair-count');
    if (input) {
      const v = parseInt(input.value);
      if (!isNaN(v) && v > 0) count = Math.min(v, items.length);
    }
    const selected = items.slice().sort(() => Math.random() - 0.5).slice(0, count);
    pairState = {
      items: selected,
      left: selected.map(it => ({ id: it.id, text: it.term })),
      right: selected.map(it => ({ id: it.id, text: it.definition })),
      matches: [],
      chosen: null
    };
    // Shuffle both columns
    pairState.left.sort(() => Math.random() - 0.5);
    pairState.right.sort(() => Math.random() - 0.5);
    renderPair();
  }
  function renderPair() {
    const area = qs('#pair-area');
    if (!pairState) { area.innerHTML = ''; return; }
    area.innerHTML = '';
    const total = pairState.items.length;
    const matchedCount = pairState.matches.length;
    qs('#pair-progress').innerText = `${matchedCount}/${total}`;
    const leftCol = el('div');
    const rightCol = el('div');
    pairState.left.forEach(item => {
      const btn = el('button', { className:'item', style:'display:block;width:100%;margin-bottom:6px;', innerText:item.text });
      if (pairState.matches.includes(item.id)) {
        btn.disabled = true;
        btn.classList.add('correct');
      }
      if (pairState.chosen && pairState.chosen.id === item.id && pairState.chosen.side === 'left') {
        btn.classList.add('primary');
      }
      btn.onclick = () => {
        if (pairState.matches.includes(item.id)) return;
        pairState.chosen = { id:item.id, side:'left', text:item.text };
        renderPair();
      };
      leftCol.appendChild(btn);
    });
    pairState.right.forEach(item => {
      const btn = el('button', { className:'item', style:'display:block;width:100%;margin-bottom:6px;', innerText:item.text });
      if (pairState.matches.includes(item.id)) {
        btn.disabled = true;
        btn.classList.add('correct');
      }
      if (pairState.chosen && pairState.chosen.id === item.id && pairState.chosen.side === 'right') {
        btn.classList.add('primary');
      }
      btn.onclick = () => {
        if (pairState.matches.includes(item.id)) return;
        // If no left selected yet, select this right
        if (!pairState.chosen || pairState.chosen.side !== 'left') {
          pairState.chosen = { id:item.id, side:'right', text:item.text };
          renderPair();
          return;
        }
        // Evaluate match
        const leftSel = pairState.chosen;
        const rightSel = { id:item.id, side:'right', text:item.text };
        if (leftSel.id === rightSel.id) {
          // correct
          pairState.matches.push(leftSel.id);
          gradeLearn(leftSel.id, 5);
          window.confettiLaunch(140);
        } else {
          // incorrect
          gradeLearn(leftSel.id, 2);
          gradeLearn(rightSel.id, 2);
        }
        pairState.chosen = null;
        // Update mastery
        computeMastery(currentSet);
        renderPair();
        // Check completion
        if (pairState.matches.length === total) {
          window.confettiLaunch(200);
        }
      };
      rightCol.appendChild(btn);
    });
    const grid = el('div', { className:'grid', style:'grid-template-columns:1fr 1fr; gap:12px;' });
    grid.appendChild(leftCol);
    grid.appendChild(rightCol);
    area.appendChild(grid);
  }

  // === Combination (Combinar) game ===
  function startComb() {
    const setId = qs('#select-comb').value || currentSet;
    if (!setId) return;
    currentSet = setId;
    const items = (db.items[setId] || []).slice();
    if (items.length < 2) { alert('Se requieren ‚â• 2 tarjetas.'); return; }
    let count = items.length;
    const inp = qs('#comb-count');
    if (inp) {
      const v = parseInt(inp.value);
      if (!isNaN(v) && v > 0) count = Math.min(v, items.length);
    }
    const selected = items.slice().sort(() => Math.random() - 0.5).slice(0, count);
    combState = { items:selected };
    renderComb();
  }
  function renderComb() {
    const area = qs('#comb-area');
    if (!combState) { area.innerHTML = ''; return; }
    area.innerHTML = '';
    qs('#comb-progress').innerText = `0/${combState.items.length}`;
    combState.items.forEach((it, idx) => {
      const row = el('div', { className:'row', style:'gap:8px; align-items:center; margin-bottom:6px;' });
      // Use a dedicated class for combination terms to avoid oversized fonts
      const term = el('div', { className:'comb-term', style:'flex:1;', innerText: it.term });
      const select = el('select', { style:'flex:1;' });
      select.appendChild(el('option', { value:'', innerText:'Seleccione...' }));
      // get definitions list and shuffle
      const defs = combState.items.slice().map(x => x.definition).sort(() => Math.random() - 0.5);
      defs.forEach(d => {
        const opt = el('option', { value:d, innerText:d });
        select.appendChild(opt);
      });
      row.appendChild(term);
      row.appendChild(select);
      area.appendChild(row);
    });
    const gradeBtn = el('button', { className:'primary', innerText:'Calificar', style:'margin-top:8px' });
    gradeBtn.onclick = gradeComb;
    area.appendChild(gradeBtn);
  }
  function gradeComb() {
    const area = qs('#comb-area');
    const rows = Array.from(area.children).filter(ch => ch.tagName !== 'BUTTON');
    let correctCount = 0;
    rows.forEach((row, idx) => {
      const item = combState.items[idx];
      const select = row.querySelector('select');
      const chosen = select.value;
      const correctDef = item.definition;
      if (chosen === correctDef) {
        correctCount++;
        row.classList.add('correct');
        gradeLearn(item.id, 5);
      } else {
        row.classList.add('incorrect');
        const ans = el('div', { className:'muted', innerText:`Correcto: ${correctDef}`, style:'margin-left:8px' });
        row.appendChild(ans);
        gradeLearn(item.id, 2);
      }
      select.disabled = true;
    });
    qs('#comb-progress').innerText = `${correctCount}/${combState.items.length}`;
    const btn = area.querySelector('button.primary');
    if (btn) btn.disabled = true;
    computeMastery(currentSet);
    if (correctCount === combState.items.length) window.confettiLaunch(200);
  }

  // === Cloze + Elaboraci√≥n game ===
  let clozeState = null;
  // Set of stopwords used for keyword extraction in cloze mode
  const CLOZE_STOP = new Set("de la las los del para por con sin sobre entre hacia desde como que una uno un y o e es son se a al en lo sus".split(/\s+/));
  // Normalize and tokenize text for keyword extraction
  const clozeToken = s => (s || "").normalize("NFD").replace(/[\u0300-\u036f]/g, "").match(/[a-z0-9√°√©√≠√≥√∫√º√±-]+/gi) || [];
  const clozeUniq = a => [...new Set(a)];
  function extractKeywords(def, k = 4) {
    const raw = def || "";
    const toks = clozeToken(raw);
    const upper = clozeUniq((raw.match(/\b[A-Z√Å√â√ç√ì√ö√ú√ë]{2,}\b/g) || []));
    const long = clozeUniq(toks.filter(w => w.length >= 6 && !CLOZE_STOP.has(w)));
    const tech = clozeUniq(toks.filter(w => /(cion|sion|miento|logia|lisis|fago|metria|plasma|genesis|oxidativa|fosforilacion|hidrolit|ribosom|membrana)/i.test(w)));
    const cand = clozeUniq([...upper, ...tech, ...long]);
    const scored = cand.map(w => ({ w, score: w.length + (/^[A-Z√Å√â√ç√ì√ö√ú√ë]{2,}$/.test(w) ? 2 : 0) })).sort((a, b) => b.score - a.score);
    const essential = scored.slice(0, Math.max(3, Math.min(k, scored.length))).map(x => x.w);
    const secondary = cand.filter(w => !essential.includes(w));
    return { essential, secondary };
  }
  function buildCloze(def, essential) {
    let txt = def;
    essential.forEach(k => {
      const rx = new RegExp("\\b" + k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + "\\b", "i");
      txt = txt.replace(rx, m => `<span class="blank" data-answer="${m}">_____</span>`);
    });
    return txt;
  }
  function evaluateElaboration(text, essential, secondary) {
    const T = (text || "").toLowerCase();
    const covHits = essential.filter(w => T.includes(w.toLowerCase())).length;
    const covScore = covHits === essential.length ? 2 : (covHits > 0 ? 1 : 0);
    const specHits = secondary.filter(w => T.includes(w.toLowerCase())).length;
    const hasEx = /por ejemplo|e\.g\.|como|similar a/i.test(text || "");
    const specScore = (specHits >= 1 || hasEx) ? 2 : 0;
    const total = covScore + specScore;
    return { total, covScore, specScore, covHits };
  }
  function startCloze() {
    const setId = qs('#select-cloze').value || currentSet;
    if (!setId) { alert('Selecciona un set'); return; }
    currentSet = setId;
    const items = (db.items[setId] || []).slice();
    if (!items.length) { alert('Set vac√≠o'); return; }
    const shuffled = items.slice().sort(() => Math.random() - 0.5);
    clozeState = { items: shuffled, index: 0, keys: null };
    renderCloze();
  }
  function renderCloze() {
    const card = qs('#cloze-card');
    if (!card) return;
    card.innerHTML = '';
    if (!clozeState || !clozeState.items.length) {
      card.innerHTML = '<p class="muted">No hay tarjetas en este set.</p>';
      qs('#cloze-progress').innerText = '0/0';
      return;
    }
    if (clozeState.index >= clozeState.items.length) {
      card.innerHTML = '<p class="muted">¬°Terminaste! Usa Iniciar para repetir.</p>';
      qs('#cloze-progress').innerText = `${clozeState.items.length}/${clozeState.items.length}`;
      return;
    }
    const item = clozeState.items[clozeState.index];
    ensureProgress(currentSet);
    const keys = extractKeywords(item.definition, 4);
    clozeState.keys = keys;
    // Header: show term and progress centered
    const header = el('div', { style: 'text-align:center; margin-bottom:8px;' });
    header.appendChild(el('div', { style: 'font-weight:700; font-size:20px; margin-bottom:4px', innerText: item.term }));
    header.appendChild(el('small', { className:'muted', innerText: `Tarjeta ${clozeState.index+1}/${clozeState.items.length}` }));
    card.appendChild(header);
    // Controls for next and reveal will be appended later as a bottom row
    const nextBtn = el('button', { innerText:'Siguiente', className:'ghost', id:'cloze-next' });
    const revealBtn = el('button', { innerText:'Ver definici√≥n', className:'ghost', id:'cloze-reveal' });
    // Cloze definition
    const clozeDef = el('div', { className:'cloze-def', id:'cloze-def', style:'margin-top:8px' });
    clozeDef.innerHTML = buildCloze(item.definition, keys.essential);
    card.appendChild(clozeDef);
    // Guess row
    const guessRow = el('div', { className:'row', style:'gap:8px; margin-top:8px; flex-wrap:wrap' });
    const guessInput = el('input', { id:'cloze-guess', placeholder:'Escribe la palabra que falta y presiona Enter', style:'flex:1' });
    const checkBtn = el('button', { id:'cloze-check', innerText:'Comprobar', className:'primary' });
    guessRow.appendChild(guessInput);
    guessRow.appendChild(checkBtn);
    card.appendChild(guessRow);
    const fb = el('div', { id:'cloze-feedback', className:'fb-box', style:'display:none' });
    card.appendChild(fb);
    // Chips and elaboration
    const chips = el('div', { className:'chips', id:'cloze-chips' });
    const chipHtml = keys.essential.map(x => `<span class="chip">‚òÖ ${x}</span>`).join(' ') + (keys.secondary.length ? `<span class="chip">sec: ${keys.secondary.slice(0,3).join(', ')}</span>` : '');
    chips.innerHTML = chipHtml;
    card.appendChild(chips);
    const ta = el('textarea', { id:'cloze-elab', placeholder:'Explica el t√©rmino en 1‚Äì2 frases. A√±ade un detalle t√©cnico o ejemplo.', style:'margin-top:6px; width:100%' });
    card.appendChild(ta);
    const evalRow = el('div', { className:'row', style:'gap:6px; margin-top:6px; align-items:center' });
    const evalBtn = el('button', { id:'cloze-eval', innerText:'Evaluar Elaboraci√≥n', className:'primary' });
    evalRow.appendChild(evalBtn);
    evalRow.appendChild(el('small', { className:'muted', innerText:'Punt√∫a: cobertura + especificidad (0‚Äì4)' }));
    card.appendChild(evalRow);
    const evalBox = el('div', { id:'cloze-evalBox', className:'fb-box', style:'display:none' });
    const row2 = el('div', { className:'row', style:'gap:8px; align-items:center' });
    row2.appendChild(el('strong', { innerText:'Resultado' }));
    const scoreSpan = el('span', { id:'cloze-score', className:'badge', innerText:'‚Äî' });
    row2.appendChild(scoreSpan);
    evalBox.appendChild(row2);
    const bar = el('div', { className:'bar', style:'margin:8px 0' });
    bar.appendChild(el('span', { id:'cloze-bar-fill' }));
    evalBox.appendChild(bar);
    const fbDiv = el('div', { id:'cloze-fb' });
    evalBox.appendChild(fbDiv);
    card.appendChild(evalBox);
    // Bottom control row: next and reveal
    const ctrlRow = el('div', { className:'row', style:'gap:8px; margin-top:12px; justify-content:center; flex-wrap:wrap' });
    ctrlRow.appendChild(nextBtn);
    ctrlRow.appendChild(revealBtn);
    card.appendChild(ctrlRow);
    // progress display
    qs('#cloze-progress').innerText = `${clozeState.index}/${clozeState.items.length}`;
    // function to check guess correctness
    function doCheck() {
      const g = guessInput.value.trim().toLowerCase();
      if (!g) return;
      const blanksEls = clozeDef.querySelectorAll('.blank');
      let ok = false;
      blanksEls.forEach(b => {
        const ans = (b.dataset.answer || '').toLowerCase();
        if (ans === g || ans.startsWith(g)) ok = true;
      });
      fb.style.display = 'block';
      fb.innerHTML = ok ? `‚úîÔ∏è <span class="badge ok">¬°Bien!</span> Coincide con un hueco.` : `‚úñÔ∏è <span class="badge err">No coincide</span>. Usa las claves como pista.`;
      if (ok) ta.focus();
    }
    guessInput.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); doCheck(); } });
    checkBtn.onclick = doCheck;
    evalBtn.onclick = () => {
      const text = ta.value.trim();
      if (!text) { alert('Escribe tu elaboraci√≥n.'); return; }
      const r = evaluateElaboration(text, keys.essential, keys.secondary);
      evalBox.style.display = 'block';
      scoreSpan.innerText = `${r.total}/4`;
      scoreSpan.className = 'badge ' + (r.total >= 3 ? 'ok' : r.total >= 2 ? 'warn' : 'err');
      evalBox.querySelector('#cloze-bar-fill').style.width = Math.round((r.total / 4) * 100) + '%';
      fbDiv.innerHTML = `‚Ä¢ Cobertura: <b>${r.covScore}/2</b> (mencionaste ${r.covHits}/${keys.essential.length}).<br>‚Ä¢ Especificidad: <b>${r.specScore}/2</b> (detalle t√©cnico o ejemplo/analog√≠a).`;
      // Determine quality based on guess and elaboration
      let quality = 2;
      const gval = guessInput.value.trim().toLowerCase();
      let okGuess = false;
      const blanksEls = clozeDef.querySelectorAll('.blank');
      blanksEls.forEach(b => {
        const ans = (b.dataset.answer || '').toLowerCase();
        if (ans === gval || ans.startsWith(gval)) okGuess = true;
      });
      if (okGuess) {
        if (r.total >= 3) quality = 5;
        else if (r.total >= 2) quality = 4;
        else quality = 3;
      } else {
        quality = 2;
      }
      gradeLearn(item.id, quality);
      computeMastery(currentSet);
      renderSets();
    };
    nextBtn.onclick = () => {
      clozeState.index = (clozeState.index + 1);
      renderCloze();
    };
    revealBtn.onclick = () => {
      alert(`Definici√≥n:\n\n${item.definition}`);
    };
  }

  // === Import/Export ===
  let importRows = [];
  qs('#file-input').addEventListener('change', e => {
    const f = e.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = () => {
      const txt = reader.result;
      importRows = [];
      if (/\.json$/i.test(f.name)) {
        try {
          const arr = JSON.parse(txt);
          if (Array.isArray(arr)) importRows = arr;
        } catch (err) { alert('JSON inv√°lido'); }
      } else {
        const rows = parseCSV(txt);
        if (!rows.length) { alert('CSV vac√≠o'); return; }
        const headers = rows.shift().map(h => h.toLowerCase());
        function idx(name) { return headers.indexOf(name); }
        rows.forEach(r => {
          const rec = {
            set_title: r[idx('set_title')] || '',
            term: r[idx('term')] || '',
            definition: r[idx('definition')] || '',
            extra_notes: r[idx('extra_notes')] || '',
            tags: (r[idx('tags')] || '').split(',').map(x => x.trim()).filter(x => !!x),
            lang_term: r[idx('lang_term')] || '',
            lang_definition: r[idx('lang_definition')] || '',
            difficulty: r[idx('difficulty')] || ''
          };
          if (rec.term && rec.definition) importRows.push(rec);
        });
      }
      qs('#import-preview').innerText = 'Listas ' + importRows.length + ' filas v√°lidas.';
      qs('#btn-import').disabled = !importRows.length;
    };
    reader.readAsText(f);
  });
  qs('#btn-import').addEventListener('click', () => {
    const groups = {};
    importRows.forEach(r => {
      const t = r.set_title || 'Mi Set';
      groups[t] = groups[t] || [];
      groups[t].push(r);
    });
    Object.keys(groups).forEach(title => {
      let found = null;
      Object.values(db.sets).forEach(s => { if (s.title === title) found = s.id; });
      let setId = found;
      if (!setId) {
        setId = uuid();
        db.sets[setId] = { id:setId, title:title, description:'', createdAt:nowISO(), updatedAt:nowISO() };
        db.items[setId] = [];
      }
      groups[title].forEach(r => {
        const exists = (db.items[setId] || []).some(x => x.term === r.term && x.definition === r.definition);
        if (!exists) {
          db.items[setId].push({ id:uuid(), term:r.term.trim(), definition:r.definition.trim(), extra_notes:r.extra_notes || '', tags:r.tags || [], difficulty: r.difficulty ? Number(r.difficulty) : null });
        }
      });
      db.sets[setId].updatedAt = nowISO();
    });
    save();
    renderAll();
    alert('Importaci√≥n completada.');
  });
  qs('#btn-export-json').addEventListener('click', () => {
    const sel = qs('#export-select');
    const setId = sel ? sel.value : '';
    if (!setId) {
      // export all sets and items
      download('pengu_export.json', JSON.stringify(db, null, 2), 'application/json;charset=utf-8');
    } else {
      const out = { sets: {}, items: {}, progress: {} };
      out.sets[setId] = db.sets[setId];
      out.items[setId] = db.items[setId] || [];
      if (db.progress[setId]) out.progress[setId] = db.progress[setId];
      const title = (db.sets[setId] && db.sets[setId].title ? db.sets[setId].title.replace(/[^a-z0-9_-]/gi,'_') : setId);
      download(`${title}_export.json`, JSON.stringify(out, null, 2), 'application/json;charset=utf-8');
    }
  });
  qs('#btn-export-csv').addEventListener('click', () => {
    const sel = qs('#export-select');
    const setId = sel ? sel.value : '';
    const rows = [ [ 'set_title','term','definition','extra_notes','tags','lang_term','lang_definition','difficulty' ] ];
    const addRows = (s) => {
      (db.items[s.id] || []).forEach(it => {
        rows.push([ s.title, it.term, it.definition, it.extra_notes || '', (it.tags || []).join(','), '', '', it.difficulty || '' ]);
      });
    };
    if (!setId) {
      Object.values(db.sets).forEach(s => addRows(s));
    } else {
      const s = db.sets[setId];
      if (s) addRows(s);
    }
    const csv = rows.map(row => row.map(val => {
      const s = String(val == null ? '' : val);
      return (s.indexOf(',') > -1 || s.indexOf('"') > -1 || s.indexOf('\n') > -1) ? '"' + s.replace(/"/g, '""') + '"' : s;
    }).join(',')).join('\n');
    const name = setId ? ((db.sets[setId] && db.sets[setId].title ? db.sets[setId].title.replace(/[^a-z0-9_-]/gi,'_') : setId) + '_export.csv') : 'pengu_export.csv';
    download(name, csv, 'text/csv;charset=utf-8');
  });
  qs('#btn-backup').addEventListener('click', () => {
    download('pengu_backup.json', JSON.stringify(db));
  });
  qs('#btn-dump').addEventListener('click', () => {
    qs('#dump-area').value = JSON.stringify(db, null, 2);
  });
  qs('#btn-restore').addEventListener('click', () => {
    try {
      const data = JSON.parse(qs('#dump-area').value || '{}');
      db = { sets: data.sets || {}, items: data.items || {}, progress: data.progress || {}, folders: data.folders || {} };
      save();
      renderAll();
      alert('Restaurado.');
    } catch (e) {
      alert('JSON inv√°lido.');
    }
  });

  // === Events for L√©elo T√∫ ===
  qs('#nav-leelo').onclick = () => { switchView('leelo'); initLeelo(); };
  qs('#select-leelo').onchange = initLeelo;
  qs('#leelo-rec').onclick = leeloStartRec;
  qs('#leelo-stop').onclick = leeloStopRec;
  qs('#leelo-play').onclick = leeloPlay;
  qs('#leelo-retry').onclick = leeloRetry;
  qs('#leelo-tts').onclick = leeloSpeak;
  qs('#leelo-prev').onclick = leeloPrev;
  qs('#leelo-next').onclick = leeloNext;

  // === Functions and state for L√©elo T√∫ ===
  let leeloState = { order: [], index: 0, recorded: {} };
  let leeloStream = null, leeloRecorder = null, leeloRecording = false, leeloT0 = 0, leeloRaf = 0, leeloLastBlob = null, leeloRecCardId = null, leeloPoints = 0;

  function leeloEnsureMic() {
    if (leeloStream && leeloStream.active) return Promise.resolve(leeloStream);
    return navigator.mediaDevices.getUserMedia({ audio: true }).then(s => {
      leeloStream = s;
      return s;
    });
  }
  window.addEventListener('beforeunload', () => {
    if (leeloStream) {
      try { leeloStream.getTracks().forEach(t => t.stop()); } catch (e) {}
    }
  });
  // IndexedDB helpers for leelo
  const LDB_NAME = 'penguAudio';
  const LDB_STORE = 'recordings';
  const LDB_VER = 1;
  function leeloOpenDB() {
    return new Promise((res, rej) => {
      const r = indexedDB.open(LDB_NAME, LDB_VER);
      r.onupgradeneeded = () => {
        const dbi = r.result;
        const st = dbi.createObjectStore(LDB_STORE, { keyPath:'id', autoIncrement:true });
        st.createIndex('by_card','cardId');
        st.createIndex('by_time','ts');
      };
      r.onsuccess = () => res(r.result);
      r.onerror = () => rej(r.error);
    });
  }
  function leeloSaveRec(cardId, blob, duration) {
    return leeloOpenDB().then(db => {
      return new Promise((res, rej) => {
        const tx = db.transaction(LDB_STORE, 'readwrite');
        const st = tx.objectStore(LDB_STORE);
        const rec = { cardId: cardId, ts: Date.now(), duration: duration, type: blob.type, blob: blob };
        const req = st.add(rec);
        req.onsuccess = () => res({ id: req.result, cardId: cardId, ts: rec.ts });
        req.onerror = () => rej(req.error);
      });
    });
  }
  function leeloListByCard(cardId) {
    return leeloOpenDB().then(db => {
      return new Promise((res, rej) => {
        const tx = db.transaction(LDB_STORE, 'readonly');
        const ix = tx.objectStore(LDB_STORE).index('by_card');
        const out = [];
        ix.openCursor(IDBKeyRange.only(cardId)).onsuccess = e => {
          const c = e.target.result;
          if (c) {
            out.push(c.value);
            c.continue();
          } else {
            out.sort((a,b) => b.ts - a.ts);
            res(out);
          }
        };
        tx.onerror = () => rej(tx.error);
      });
    });
  }
  function initLeelo() {
    const sel = qs('#select-leelo');
    const setId = sel && sel.value ? sel.value : currentSet;
    if (!setId) return;
    currentSet = setId;
    const items = (db.items[setId] || []).slice();
    leeloState.order = items.map((_, i) => i);
    leeloState.index = 0;
    leeloState.recorded = {};
    leeloPoints = 0;
    renderLeelo();
  }
  function renderLeelo() {
    const items = db.items[currentSet] || [];
    if (!items.length) {
      qs('#leelo-term').innerText = '(vac√≠o)';
      qs('#leelo-def').innerText = 'Agrega tarjetas';
      qs('#leelo-score').innerText = '0 pts';
      leeloLastBlob = null;
      return;
    }
    const i = leeloState.order[leeloState.index];
    const it = items[i];
    qs('#leelo-term').innerText = it.term || '‚Äî';
    qs('#leelo-def').innerText = it.definition || '';
    const cardId = 'deck:' + it.id;
    leeloRecCardId = cardId;
    // Load last recording for this card
    leeloListByCard(cardId).then(recs => {
      if (recs.length) {
        leeloLastBlob = recs[0].blob;
        const url = URL.createObjectURL(leeloLastBlob);
        qs('#leelo-audio').src = url;
        qs('#leelo-when').innerText = new Date(recs[0].ts).toLocaleString();
        qs('#leelo-recent').classList.add('on');
        qs('#leelo-play').disabled = false;
        qs('#leelo-retry').disabled = false;
      } else {
        leeloLastBlob = null;
        qs('#leelo-audio').removeAttribute('src');
        qs('#leelo-when').innerText = '';
        qs('#leelo-recent').classList.remove('on');
        qs('#leelo-play').disabled = true;
        qs('#leelo-retry').disabled = true;
      }
    });
    // Update nav buttons
    qs('#leelo-prev').disabled = (leeloState.index <= 0);
    qs('#leelo-next').disabled = (leeloState.index >= leeloState.order.length - 1);
    qs('#leelo-score').innerText = leeloPoints + ' pts';
    // Auto start recording if enabled
    if (qs('#leelo-auto').checked) {
      setTimeout(leeloStartRec, 200);
    }
  }
  function leeloStartRec() {
    if (leeloRecording) return;
    const items = db.items[currentSet] || [];
    if (!items.length) return;
    leeloEnsureMic().then(() => {
      const currentItem = items[leeloState.order[leeloState.index]];
      const cid = 'deck:' + currentItem.id;
      leeloRecCardId = cid;
      leeloRecorder = new MediaRecorder(leeloStream, { mimeType: 'audio/webm' });
      const chunks = [];
      leeloRecorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
      leeloRecorder.onstop = () => {
        const blob = new Blob(chunks, { type: 'audio/webm' });
        leeloLastBlob = blob;
        const duration = Math.max(0, (performance.now() - leeloT0) / 1000);
        const recId = leeloRecCardId || cid;
        leeloSaveRec(recId, blob, duration).then(saved => {
          // update UI if still on same card
          const currentCardId = 'deck:' + (db.items[currentSet][leeloState.order[leeloState.index]].id);
          if (recId === currentCardId) {
            const url = URL.createObjectURL(blob);
            qs('#leelo-audio').src = url;
            qs('#leelo-when').innerText = new Date(saved.ts).toLocaleString();
            qs('#leelo-recent').classList.add('on');
            qs('#leelo-play').disabled = false;
            qs('#leelo-retry').disabled = false;
          }
          // award points once per card
          if (!leeloState.recorded[recId]) {
            leeloState.recorded[recId] = true;
            leeloPoints++;
          }
          qs('#leelo-score').innerText = leeloPoints + ' pts';
          // auto advance if enabled
          if (qs('#leelo-auto-advance').checked && leeloState.index < leeloState.order.length - 1 && recId === currentCardId) {
            leeloState.index++;
            renderLeelo();
          }
        });
        leeloRecording = false;
        qs('#leelo-rec').disabled = false;
        qs('#leelo-stop').disabled = true;
        qs('#leelo-tts').disabled = false;
        qs('#leelo-play').disabled = !leeloLastBlob;
        qs('#leelo-retry').disabled = !leeloLastBlob;
      };
      leeloT0 = performance.now();
      leeloRecording = true;
      qs('#leelo-rec').disabled = true;
      qs('#leelo-stop').disabled = false;
      qs('#leelo-tts').disabled = true;
      qs('#leelo-play').disabled = true;
      qs('#leelo-retry').disabled = true;
      tickLeeloTimer();
      leeloRecorder.start();
    }).catch(() => {
      alert('No se pudo acceder al micr√≥fono');
    });
  }
  function leeloStopRec() {
    if (!leeloRecording) return;
    leeloRecording = false;
    cancelAnimationFrame(leeloRaf);
    qs('#leelo-stop').disabled = true;
    try { if (leeloRecorder && leeloRecorder.state !== 'inactive') leeloRecorder.stop(); } catch (e) {}
  }
  function tickLeeloTimer() {
    const t = (performance.now() - leeloT0) / 1000;
    const m = String(Math.floor(t / 60)).padStart(2, '0');
    const s = String(Math.floor(t % 60)).padStart(2, '0');
    qs('#leelo-timer').innerText = m + ':' + s;
    leeloRaf = requestAnimationFrame(tickLeeloTimer);
  }
  function leeloPlay() {
    if (!leeloLastBlob) return;
    const url = URL.createObjectURL(leeloLastBlob);
    const a = new Audio(url);
    a.play();
    a.onended = () => URL.revokeObjectURL(url);
  }
  function leeloRetry() {
    leeloLastBlob = null;
    qs('#leelo-play').disabled = true;
    qs('#leelo-retry').disabled = true;
    qs('#leelo-recent').classList.remove('on');
    qs('#leelo-when').innerText = '';
    qs('#leelo-audio').removeAttribute('src');
  }
  function leeloSpeak() {
    const term = qs('#leelo-term').innerText || '';
    const def = qs('#leelo-def').innerText || '';
    const txt = term + (def ? ': ' + def : '');
    const u = new SpeechSynthesisUtterance(txt);
    u.lang = /[√°√©√≠√≥√∫√±¬ø¬°]/i.test(txt) ? 'es-ES' : 'en-US';
    u.rate = 0.95;
    u.pitch = 1.02;
    speechSynthesis.speak(u);
  }
  function leeloPrev() {
    if (leeloState.index <= 0) return;
    leeloState.index--;
    renderLeelo();
  }
  function leeloNext() {
    if (leeloState.index >= leeloState.order.length - 1) return;
    leeloState.index++;
    renderLeelo();
  }

  // === Navigation ===
  function switchView(name) {
    ['sets','flash','leelo','learn','test','match','pair','comb','cloze','import'].forEach(v => {
      const sec = qs('#view-' + v);
      if (sec) sec.classList.add('hidden');
    });
    const active = qs('#view-' + name);
    if (active) active.classList.remove('hidden');
    ['nav-sets','nav-flash','nav-leelo','nav-learn','nav-test','nav-match','nav-memory','nav-comb','nav-pair','nav-cloze','nav-import'].forEach(id => {
      const btn = qs('#' + id);
      if (btn) btn.classList.remove('primary');
    });
    let navBtn = qs('#nav-' + name);
    if (!navBtn && name === 'match') navBtn = qs('#nav-memory');
    if (!navBtn && name === 'pair') navBtn = qs('#nav-pair');
    if (!navBtn && name === 'comb') navBtn = qs('#nav-comb');
    if (navBtn) navBtn.classList.add('primary');
    if (name === 'flash') initFlash();
    if (name === 'learn') renderLearn();
    if (name === 'test') { currentTest = null; renderTest(); }
    if (name === 'match') {
      matchState = null;
      qs('#match-area').innerHTML = '';
      qs('#match-moves').innerText = 'Movimientos: 0';
      qs('#match-progress').innerText = '0/0';
    }
    if (name === 'pair') {
      pairState = null;
      qs('#pair-area').innerHTML = '';
      qs('#pair-progress').innerText = '0/0';
    }
    if (name === 'comb') {
      combState = null;
      qs('#comb-area').innerHTML = '';
      qs('#comb-progress').innerText = '0/0';
    }
    if (name === 'cloze') {
      // when entering cloze view, render card
      renderCloze();
    }
    if (name === 'leelo') {
      initLeelo();
    }

    // Stop flash autoplay when leaving flash view
    if (name !== 'flash' && flashAuto) {
      flashAuto = false;
      clearTimeout(flashAutoTimer);
      const btn = qs('#flash-auto');
      if (btn) {
        btn.classList.remove('primary');
        btn.innerText = 'Auto';
      }
    }
  }
  qs('#nav-sets').onclick = () => { switchView('sets'); };
  qs('#nav-flash').onclick = () => { switchView('flash'); };
  qs('#nav-learn').onclick = () => { switchView('learn'); };
  qs('#nav-test').onclick = () => { switchView('test'); };
  qs('#nav-memory').onclick = () => { switchView('match'); };
  qs('#nav-comb').onclick = () => { switchView('comb'); };
  qs('#nav-pair').onclick = () => { switchView('pair'); };
  qs('#nav-cloze').onclick = () => { switchView('cloze'); };
  qs('#nav-import').onclick = () => { switchView('import'); };

  // === Modals and events for sets ===
  qs('#btn-new-set').onclick = () => {
    qs('#scrim').style.display = 'flex';
    qs('#new-title').value = '';
    qs('#new-desc').value = '';
    // Populate folder dropdown with current folders
    const sel = qs('#new-folder-select');
    if (sel) {
      sel.innerHTML = '<option value="">Sin carpeta</option>';
      Object.values(db.folders).forEach(f => {
        const opt = document.createElement('option');
        opt.value = f.id;
        opt.textContent = f.name;
        sel.appendChild(opt);
      });
    }
  };

  // Folder management modal
  qs('#btn-new-folder').onclick = () => {
    // Reset the input and show folder modal
    qs('#folder-name').value = '';
    qs('#scrim-folder').style.display = 'flex';
  };
  qs('#folder-cancel').onclick = () => {
    qs('#scrim-folder').style.display = 'none';
  };
  qs('#folder-ok').onclick = () => {
    const name = (qs('#folder-name').value || '').trim();
    if (!name) {
      alert('Nombre de carpeta requerido');
      return;
    }
    // Avoid creating duplicate folders (case-insensitive)
    const exists = Object.values(db.folders).some(f => {
      return (f.name || '').trim().toLowerCase() === name.toLowerCase();
    });
    if (exists) {
      alert('Ya existe una carpeta con ese nombre');
      // Hide modal without adding a new folder
      qs('#scrim-folder').style.display = 'none';
      return;
    }
    // Generate unique id for folder and add to db
    const id = uuid();
    db.folders[id] = { id: id, name: name, createdAt: nowISO() };
    save();
    qs('#scrim-folder').style.display = 'none';
    renderAll();
  };
  qs('#modal-cancel').onclick = () => { qs('#scrim').style.display = 'none'; };
  qs('#modal-ok').onclick = () => {
    const title = (qs('#new-title').value || '').trim();
    if (!title) { alert('T√≠tulo requerido'); return; }
    const id = uuid();
    // Determine folder assignment
    const folderSel = qs('#new-folder-select');
    const folderId = (folderSel && folderSel.value) ? folderSel.value : null;
    db.sets[id] = { id:id, title:title, description: (qs('#new-desc').value || '').trim(), folder: folderId, createdAt: nowISO(), updatedAt: nowISO() };
    db.items[id] = [];
    save();
    qs('#scrim').style.display = 'none';
    renderAll();
  };
  qs('#btn-clear').onclick = () => {
    if (confirm('Esto borrar√° TODOS los sets y progreso.')) {
      localStorage.removeItem(STORAGE_KEY);
      load();
      renderAll();
    }
  };

  // === Functions for adding multiple cards ===
  function addCardPrompt(setId) {
    multiSetId = setId;
    const form = qs('#multi-form');
    form.innerHTML = '';
    addRow();
    qs('#scrim-cards').style.display = 'flex';
  }
  function addRow() {
    const row = el('div', { className: 'row', style: 'gap:8px; align-items:flex-start; flex-wrap:wrap; width:100%' });
    const termInput = el('input', { placeholder:'T√©rmino', style:'flex:1 1 250px; min-width:200px' });
    const defInput = el('input', { placeholder:'Definici√≥n', style:'flex:1 1 250px; min-width:200px' });
    // Optional image input for manual cards
    const imgInput = el('input', { type:'file', accept:'image/*', style:'flex:1 1 250px; min-width:200px; max-width:100%' });
    const delBtn = el('button', { innerText:'√ó', className:'danger', style:'padding:0 12px; flex:0 0 auto' });
    delBtn.onclick = () => { row.remove(); };
    row.appendChild(termInput);
    row.appendChild(defInput);
    row.appendChild(imgInput);
    row.appendChild(delBtn);
    qs('#multi-form').appendChild(row);
  }
  qs('#btn-add-row').onclick = addRow;
  qs('#btn-save-cards').onclick = async () => {
    if (!multiSetId) { qs('#scrim-cards').style.display = 'none'; return; }
    const rows = Array.from(qs('#multi-form').children);
    const itemsToAdd = [];
    for (const r of rows) {
      const termInput = r.querySelector('input[placeholder="T√©rmino"]');
      const defInput = r.querySelector('input[placeholder="Definici√≥n"]');
      if (!termInput || !defInput) continue;
      const term = (termInput.value || '').trim();
      const def = (defInput.value || '').trim();
      if (!term || !def) continue;
      // Check for image
      let imgData = null;
      const fileInp = r.querySelector('input[type="file"]');
      if (fileInp && fileInp.files && fileInp.files[0]) {
        imgData = await new Promise(resolve => {
          const reader = new FileReader();
          reader.onload = (e) => resolve(e.target.result);
          reader.readAsDataURL(fileInp.files[0]);
        });
      }
      // Avoid duplicates (term+def)
      db.items[multiSetId] = db.items[multiSetId] || [];
      const exists = db.items[multiSetId].some(x => x.term === term && x.definition === def);
      if (!exists) {
        itemsToAdd.push({ id: uuid(), term: term, definition: def, image: imgData || null, extra_notes: '', tags: [], difficulty: null });
      }
    }
    if (itemsToAdd.length) {
      db.items[multiSetId] = db.items[multiSetId] || [];
      itemsToAdd.forEach(it => db.items[multiSetId].push(it));
      if (db.sets[multiSetId]) db.sets[multiSetId].updatedAt = nowISO();
      save();
    }
    qs('#scrim-cards').style.display = 'none';
    renderAll();
  };
  qs('#btn-cancel-cards').onclick = () => {
    qs('#scrim-cards').style.display = 'none';
  };

  // === Events for flashcards ===
  qs('#select-flash').onchange = initFlash;
  qs('#flash-reverse').onclick = () => { flashState.reversed = !flashState.reversed; renderFlash(); };
  qs('#flash-shuffle').onclick = () => { flashState.order.sort(() => Math.random() - 0.5); flashState.index = 0; renderFlash(); };
  qs('#flash-prev').onclick = flashPrev;
  qs('#flash-next').onclick = flashNext;
  qs('#flash-show').onclick = flashFlip;
  qs('#flash-card').addEventListener('click', e => {
    if (e.target.tagName === 'BUTTON' || e.target.closest('button') || e.target.closest('select')) return;
    flashFlip();
  });
  // Autoplay for flashcards: flip and advance every 5 seconds when activated
  qs('#flash-auto').onclick = () => {
    flashAuto = !flashAuto;
    const btn = qs('#flash-auto');
    if (flashAuto) {
      // highlight button to indicate active
      btn.classList.add('primary');
      btn.innerText = 'Auto ON';
      flashAutoFlipped = false;
      clearTimeout(flashAutoTimer);
      function step() {
        if (!flashAuto) return;
        if (!flashAutoFlipped) {
          flashFlip();
          flashAutoFlipped = true;
        } else {
          flashNext();
          flashAutoFlipped = false;
        }
        flashAutoTimer = setTimeout(step, 5000);
      }
      flashAutoTimer = setTimeout(step, 5000);
    } else {
      btn.classList.remove('primary');
      btn.innerText = 'Auto';
      clearTimeout(flashAutoTimer);
    }
  };
  // There are no hard/easy buttons in flashcards; study by flipping and using autoplay/manual navigation.
  // No grading buttons in flash view; flashcards can be studied manually or via autoplay.
  const cardEl = () => qs('#flash-card');
  cardEl().addEventListener('touchstart', handleTouchStart, { passive: true });
  cardEl().addEventListener('touchmove', handleTouchMove, { passive: true });
  cardEl().addEventListener('touchend', handleTouchEnd);
  document.addEventListener('keydown', e => {
    if (qs('#view-flash').classList.contains('hidden')) return;
    if (e.code === 'Space') { e.preventDefault(); flashFlip(); }
    if (e.code === 'ArrowLeft') flashPrev();
    if (e.code === 'ArrowRight') flashNext();
  });

  // TTS for flashcards: speak the visible side of the card
  qs('#flash-tts').onclick = () => {
    const inner = qs('#flash-inner');
    const isFlipped = inner.classList.contains('flipped');
    const text = isFlipped ? qs('#flash-back').innerText : qs('#flash-front').innerText;
    const utter = new SpeechSynthesisUtterance(text);
    utter.lang = /[√°√©√≠√≥√∫√±¬ø¬°]/i.test(text) ? 'es-ES' : 'en-US';
    utter.rate = 0.95;
    utter.pitch = 1.02;
    speechSynthesis.speak(utter);
  };

  // (Removed global click handler for flash hard/easy)

  // === Events for Learn ===
  qs('#select-learn').onchange = renderLearn;
  qs('#learn-mode').onchange = renderLearn;
  qs('#learn-direction').onchange = renderLearn;
  qs('#learn-reset').onclick = () => {
    if (!currentSet) return;
    if (confirm('¬øReiniciar progreso de este set?')) {
      delete db.progress[currentSet];
      save();
      renderLearn();
    }
  };

  // === Events for Test ===
  qs('#select-test').onchange = () => { currentTest = null; renderTest(); };
  qs('#test-generate').onclick = genTest;
  qs('#test-grade').onclick = gradeTest;
  qs('#test-reset').onclick = () => {
    currentTest = null;
    renderTest();
    qs('#test-report').classList.add('hidden');
  };

  // === Events for Match ===
  qs('#select-match').onchange = () => {};
  qs('#match-start').onclick = startMatch;

  // === Events for Pair and Combination games ===
  qs('#pair-start').onclick = startPair;
  qs('#comb-start').onclick = startComb;
  // Cloze game start button
  qs('#cloze-start').onclick = startCloze;

  // === Initialization ===
  function renderAll() {
    syncSelectors();
    renderSets();
    if (currentSet) {
      initFlash();
      renderLearn();
    }
  }
  load();
  renderAll();
  switchView('sets');

  </script>
</body>
</html>